# Behavioral Design Patterns

### Chain of Responsibility

"Chain of Responsibility" е шаблон, който дефинира свързан лист от елементи, всеки от които е способен да изпълнява заявки. Всяка една заявка започва от първият елемент в листа, който може да изпълнява такива и продължава надолу по веригата с наследници. Това продължава докато заявката се изпълни успешно или няма повече наследници. 
Един от основните проблеми, с който се справя този шаблон е нуждата дадено събитие създадено от един обект да бъде изпълнено от друг. Положителна страна е и това, че обектът, който изпраща командата не знае кой точно обект ще я изпълни.

Тази UML диаграмата показва имплементацията на "Chain of Responsibility" шаблона. Диаграмата се състои от три части:

* Client - този клас подава команди или заявки към първият обект от веригата.
* HandlerBase - представлява интефейс или базов клас. Съдържа променлива сочеща към следващия обект от веригата.
* ConcreteHandlers - това са конкретните имплементации на базовия клас.

![alt text](http://www.codeproject.com/KB/architecture/455228/chain_of_responsibility.jpg)

---
### Mediator

"Mediator" е поредния "behavioral design" шаблон. Чрез него се подобрява разкачеността между отделните обекти, като се премахва нуждата от директна комуникация. Вместо това се използват междинни("mediator") обекти, които да енкапсулират и централизират взаимоотношенията между класовете.
Има ситуации, в които дадена програма е съставена от големи класове. Това не е нещо необичайно, но причинява големи главоболия когато два подобни класа трябва да общуват един с друг. Ако се използва традиционния подход и комуникацията е директна, всеки от класовете трябва да знае вътрешната имплементация на другия, което води до повече и по-сложен код, труден за четене и разбиране.
Точно това е и основния проблем, с който се справя "mediator" шаблона. Вместо директна комуникация, класовете изпращат съобщения до междинния клас, който от своя страна ги препраща към класа, за който са предназначени.

Тази UML диаграмата показва имплементацията на "Mediator" шаблона. Диаграмата се състои от четири части:
* ColleagueBase - това е абстрактния клас за всички конкретни колеги. Съдържа поле с референция към междинния обект.
* ConcreteColleague - това е имплементацията на абстрактния клас ColleagueBase.
* MediatorBase - това е абстрактния клас за междинния обект. Той съдържа методи, които могат да бъдат използвани от ConcreteColleague класовете.
* ConcreateMediator - този клас имплементира комуникационните методи на базовия клас - MediatorBase. Съдържа референция към всички класове, които трябва да комуникират помежду си.

![alt text](http://www.codeproject.com/KB/architecture/455228/mediator.jpg)

---

### State

"State" шаблона позволява даден обект да промени изцяло държанието си при промени във вътрешно му състояние. Тези промени се случват по време на изпълнение на програмата и без да е нужно да се сменят интерфейсите, чрез които се достъпва обекта. Този шаблон е изключително полезен при създаването на софтуерни "state" машини, при които функционалността на даден обект се променя коренно в зависимост от моментното му състояние.

Тази UML диаграмата показва имплементацията на "State" шаблона. Диаграмата се състои от три части:
* Context - този клас съдържа "state" обекта, който предоставя конкретно поведение в зависимост от моментното състояние.
* StateBase - това е абстрактния клас за всички конкретни "state" класове.
* ConcreteState - това е имплементацията на StateBase класа, която предоставя реална функционалност.

![alt text](http://www.codeproject.com/KB/architecture/455228/state.jpg)

---

### Strategy

"Strategy" шаблона позволява набор от сходни алгоритми да бъдат дефинирани и енкапсулирани в собствени класове. След това нужният алгоритъм може да бъде избран при работеща програма в зависимост от изискванията.
Този шаблон може да бъде използван в подобни ситуации, където класовете се различават само в поведение. В такива случаи е добра идея тези поведения да се разделят в отделни класове, които могат да се избират по време на изпълнение на програмата. 
Този шаблон създава семейство от алгоритми и ги прави взаимнозаменяеми. Това позволява поведенията да са независими от клиентите, които ги ползват и прави програмата по-гъвкава, а добавянето на нови алгоритми в бъдеще - значително по-лесно.

Тази UML диаграмата показва имплементацията на "Strategy" шаблона. Диаграмата се състои от три части:

* Client - този клас използва взаимнозаменяеми алгоритми. Съдържа референция към StrategyBase обекта.
* StrategyBase - декларира общ интерфейс за всички използвани алгоритми. Client използва този интерфейс за да извиква дефинираните алгоритми.
* ConcreteStrategy - това е конкретния "strategy" клас наследник на StrategyBase класа. Всяка една инстанция дава достъп до различен алгоритъм.

![alt text](http://www.codeproject.com/KB/architecture/455228/strategy.jpg)